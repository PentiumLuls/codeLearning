import React from 'react';

export const notes = [[
    {
        title: "Добро пожаловать, Герой",
        text: [
            {
                title: "Пролог",
                text: `Мир ООП — грязный и жестокий. Напротив же, мир функционального программирования. Он предлагает 
                невиданные ранее возможности.
                Этот квест поможет тебе освоить функциональное программирование. 
                Тебе предстоит спасти жителей этого мира от грязных лап демона Мефисто, поработившего нагрешивших бедолаг.
                Место действий - "Функционилище" — последнее пристанище ООПшников. Прошу проходить, для тебя мы подготовили
                особый котёл~`
            },
            {
                title: "Окно приветствия",
                text: <div><p>В начале некоторых уровней ты сможешь просмотреть полезную информацию об испытании,
                    например, туториал к нему. Желаешь посмотреть еще раз? Не беда! Всю эту информацию ты сможешь найти
                    в журнале</p>
                    <img className="image-flex" src={require("../../src/img/popup.jpeg")}/></div>
            },
            {
                title: "Левая панель",
                text: <div><p>На левой панели находится список квестов и переключатели между журналом и редактором кода.
                    Ты можешь свободно переключаться между квестами, которые тебе доступны"</p>
                    <img className="image-flex" src={require("../../src/img/leftpanel.jpeg")}/></div>
            },
            {
                title: "Квесты",
                text: <div><p>В редакторе ты можешь писать свой код. Чтобы запустить его, нажми кнопку 'Run code'
                    или выполни комбинацию ctrl+shift+x. Если задание выполнено правильно, разблокируется следующий квест.
                    Запутался в коде? Нажми кнопку 'Reset'. После прохождения квеста появится кнопка NEXT LEVEL, как
                    думаешь, что она делает?</p>
                    <img className="image-flex" src={require("../../src/img/codeditor.jpeg")}/></div>
            },
            {
                title: "Терминал",
                text: <div><p>Результат запуска твоего кода будет отображаться здесь. А ещё ты можешь очистить его с
                    помощью нажатия кнопки 'Clear terminal'</p>
                    <img className="image-flex" src={require("../../src/img/terminal.jpeg")}/></div>
            },
            {
                title: "Чат",
                text: <div><p>В чате к тебе будут обращаться сюжетные персонажи. Здесь же ты можешь запросить
                    подсказку. В режиме журнала чат недоступен.</p>
                    <img className="image-flex" src={require("../../src/img/chatbox.jpeg")}/></div>
            },
            {
                title: "Журнал",
                text: <div><p>Если будет нужна помощь, заглядывай в журнал. Здесь ты сможешь найти различные руководства
                    и туториалы к уровням</p>
                    <img className="image-flex" src={require("../../src/img/journal.jpeg")}/></div>
            },
        ]
    },
    {
        title: "6 функциональных законов",
        text: [
            {
                title: "Не загрязняй функцию свою",
                text: `Функции, как и вы, люди, хотят быть чистыми. И если функция чувствует, что она стала грязной,
            она обязательно закидает тебя ошибками. Что же делает функцию грязной? Представьте,
            что вы функция, и вокруг вас коробка (область видимости), а вокруг нее куча грязи.
            Если вы хотите взять что-то извне, вам нужно сходить за этим через грязь, и, тоже самое,
            если вы хотите что-то изменить снаружи. И ведь все, чего вы хотите в этой жизни —
            это просто жить в коробке и никого не трогать. Когда вы кому-то нужны, они закидывают вам какие-то вещи,
            вы что-то с ними сделали и выкинули другой результат (новые вещи)`,
            },
            {
                title: "Делай функцию свою или первокласной или высшей",
                text: `Запомни раз и навсегда, есть 2 типа функций : одни хотят править,
            а другие хотят чтобы правили ими.`,
            },
            {
                title: "Весь мир это функция, а мы в ней константы",
                text: `Все вокруг — константы: ты, твои друзья, родственники. Представь, если бы
            все твои друзья постоянно меняли имена и место жительства,
            смог бы ты запомнить все изменения? Нужен друг с другим именем?
            Не проблема, создай нового.`,
            },
            {
                title: "Лямбда всему голова",
                text: `Как я и говорил ранее, весь мир — это функция, так вот, я не шутил. Функции везде,
            и они могут передавать друг другу значения — это операция карирования. Так вот, карирование —
            это как конвейер. По конвейеру едут данные, и в каждой функции (чем дальше едет конвейер)
            мы добавляем новые данные.`,
            },
            {
                title: "Рекурсия - лучшый друг программиста",
                text: `Забудь о циклах, вроде for и while!!! Зачем они тебе, если можно всё заменить на рекурсию —
            и возможностей больше, и побочных эффектов можно избежать`,
            },
            {
                title: "Артефакты спасут мир",
                text: `Только истинный последователь сможет овладеть артефактом, который поможет ему
            в выполнении тысяч вселенских задач и спасении от нарушения функциональных грехов.
            А по легенде, однажды придет герой, который соберет все 3 артефакта и разобьет оковы
            с вечных рабов преисподней и подарит миру свободу`,
            },
        ]
    },
    {
        title: "Чистые функции",
        text: [
            {
                title: "Чистее некуда",
                text: `Чистой называют функцию, которая является детерминированной и не имеет побочных эффектов.`,
            },
            {
                title: "Детерминированная?",
                text: `Детерминированной называется функция, которая при одинаковом наборе входных данных,
                вернет одно и то же значение. Детерминированой является функция slice, в отличие от splice,
                ведь slice возвращает новое значение, а splice мутирует изначальный массив.`,
            },
            {
                title: "Побочные эффекты?",
                text: `Побочными эффектами функции называют взаимодействие функции с окружающим миром. 
                Функция без побочных эффектов может обращаться и изменять данные только внутри себя.`,
            },
        ]
    },
    {
        title: "Иммутабельность",
        text: [
            {
                title: "Иммутабельность",
                text: `Неизменяемым (Иммутабельным) называется объект, состояние которого не может быть изменено после 
                создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится. `,
            },
            {
                title: "Иммутабельность в JS",
                text: `В JS для клонирования элементов предусмотрено несколько способов, например использовать const newObject = Object.assign({}, object), 
                или использовать spread оператор const newMass = [...mass]. Чтобы обезопасить себя от мутации, обьявляйте переменные при помощи const.`,
            },
            {
                title: "Лучшие методы",
                text: `Также плохой практикой считается использование методов вроде splice, которые изменяют начальный массив. 
                Вместо них стоит использовать методы вроде filter, map, reduce, которые возвращают новый обьект.`,
            },
        ]
    },

    {
        title: "Объединение в отряды",
        text: [
            {
                title: "Что-то про отряды",
                text: `Для большей эффективности в плане боевой силы, индусы любят объединяться в отряды. В чём заключается эффективность,
                кажется, не знают даже сами индусы. Однако, так они лучше себя чувствуют на поле боя, так как при разбитии
                на отряды складывается иллюзия существования какой-то тактики или стратегии. На деле же вся стратегия заключается
                в том, что ты хардкодишь всех до смерти. Совет да смерть.`,
            },

        ]
    }

],
    [
        {
            title: "Filter. Что и как?",
            text: [
                {
                    title: "Причина использовать filter",
                    text: `Представьте что у вас есть массив чисел, и вам нужно оставить в нем только четные.
                           Конечно, можно перебирать массив в цикле, смотреть на то, какое число передано и добавлять в новый массив, если оно четное(
                           Грустно, не правда ли? Но бородатые дядьки постарались и придумали filter.`,
                },
                {
                    title: "На что способен filter",
                    text: `Всякий раз, когда вам надо отфильтровать массив в JavaScript — встроенный метод для отфильтровки вашего массива — это хороший выбор. 
                    filter() даёт вам право сделать callback для каждого элемента и вернуть отфильтрованный массив.
                    filter() выполняет callback и проверяет возвращаемое значение. Если значение верное,
                     то оно будет добавлено в новый массив. Если нет — то оно будет из него исключено.`,
                },
                {
                    title: "Что засунуть в callback",
                    text: `В первой главе вы писали чистые функции, которые принимают значение и возращают true или false, например isBlack.
                            Именно такие ЧИСТЫЕ функции нужно пихать в filter.
                            Также обратите внимание на то, что filter() не трогает существующий массив, он будет возвращать только новый отфильтрованный массив каждый раз.`,
                }
            ]
        },
        {
            title: "Map. Просто и со вкусом",
            text: [
                {
                    title: "Причина использовать map",
                    text: `Когда мы учили filter, мы создали массив с четными числами. А теперь представьте, что вам их нужно сделать нечетными, прибавить единицу.
                           Так, ну мы можем в цыкле for пройтись по старому массиву и к каждому элементу добавить эту единицу. В принципе, мы можем это сделать,
                            но это будет смотреться некрасиво и громоздко. Намного проще и понятнее написать одну строчку с методом map.`,
                },
                {
                    title: "На что способен map",
                    text: `map() берет callback и применяет его на всех элементах массива. Но то, что делает его уникальным — он
                         генерирует новый массив, основываясь на существующем массиве. В новый массив попадут значения, которые возращает callback,
                         принимая каждый элемент массива.`,
                },
                {
                    title: "Что засунуть в callback",
                    text: `В первой главе вы писали чистые функции, которые принимают значение и возращают другое, новое значение, например perimeter.
                            Именно такие, ЧИСТЫЕ функции, нужно пихать в map.
                            Как и filter(), map() возвращает массив. Указанный callback для map() изменит элементы массива и сохранит их в новый массив
                             по завершении того, как массив будет возвращен как отmapенный массив.`,
                }
            ]
        },
        {
            title: "Reduce, да это жестко",
            text: [
                {
                    title: "Причина использовать reduce",
                    text: `Давайте возьмем самую банальную задачу: получить сумму всех чисел в массиве. Ну, тут все просто, делаем
                           цикл for и прибавляем каждый елемент массива в переменную sum. Казалось бы, куда проще,
                           но тут в игру вступает reduce.`,
                },
                {
                    title: "На что способен reduce",
                    text: `Как можно было предположить по названию, этот метод используется для того, чтобы сократить массив в одно простое значение.
                    reduce() берет callback, как и любая функция, о которой мы говорили. Внутри этого callback мы берем два аргумента — sum и elem.
                     sum — это последнее вернувшееся значение функции reduce(). Для примера, изначально значение sum будет равно 0, 
                     затем, когда запустится callback на первом элементе, он прибавит elem к sum и возвратит значение. 
                     На второй итерации sum значение будет  равно: первый elem + 0, на второй итерации 0 + первый elem + второй elem.`,
                },
                {
                    title: "Что засунуть в callback",
                    text: `В первой главе вы писали чистые функции, которые принимают два значения и возвращают одно, например add.
                            Таких функций можно придумать множество.`,
                }
            ]
        },
    ],

    [
        {
            title: "Чейнинг методов",
            text: [
                {
                    title: "Да это жестко",
                    text: `Методы map, filter и reduce очень удобные и мощные даже по отдельности, но представьте, какие возможности можно получить,
                    если использовать их все вместе...`,
                },
                {
                    title: "Цепочка вызовов",
                    text: `Как вы уже знаете, map, filter и reduce возвращают новое значение, а значит мы можем использовать их друг за другом, комбинируя как нашей душе угодно. obj.filter(f).map(f) - такой способ называеться чейнинг методов. Это хороший объектно-ориентированный подход к проектированию. Теперь, если вы посмотрите внимательней, вы заметите, как он работает, и чего ему не хватает.

                    Данные Hello передаются по цепочке совместимых методов, и мы можем использовать сколько угодно методов, пока возвращаемый объект совместим с ними.`,
                },
                {
                    title: "Проблема и её решение",
                    text: `Вышеупомянутая конструкция возможна из-за объекта obj: все методы в цепочке бесполезны без объекта,
                     предоставляющего их. Это грустно. Проблема конкретно здесь и с каждым объектно-ориентированным подходом к
                      проектированиюв том, что всё крутится вокруг объектов, всё зависит от данных.
                      Но не волнуйтесь, позже мы решим эту проблему с помощь карирования и частичного применения, но пока что научитесь правильно использовать чейнинг.`,
                }
            ]
        }
    ],

    [
        {
            title: "Частичное применение",
            text: [
                {
                    title: "Шо там частичное?",
                    text: `Предоставление функции с меньшим количеством аргументов, чем она ожидает, называется частичным применением функции.

                    Хоть концепция проста, её можно использовать для подготовки более сильных функциональных конструкций в нашем повседневном JavaScript.`,
                },
                {
                    title: "Причина использовать",
                    text: `Давайте представим простую задачу с цифрами, там нужно добавить два числа, такую функцию вы уже писали.
                    Но что, если нам нужно несколько раз добавлять число, при этом меняется только второе значение. В нашей старой реализации мы бы писали: add(2, 6); add(2, 5) ... Как видите цифра 2 постоянно повторяется. Используя частичное применение, мы могли "замкнуть" цифру 2, и просто писать:
                    add2(6); add2(5) ... Удобно, не правда ли?`,
                },
                {
                    title: "Реализация ЧП",
                    text: `Этот стиль частичного применения не является функционально верным, но я хочу, чтобы вы знали о нем. Пример частичного применения функций с помощью bind():
                    let add = (a, b) => a+b;
                    let incrementBy2 = add.bind(null,2);
                    incrementBy2(6)
                    incrementBy2(5)
                    Вдаваться в подробности не буду, так как такой метод никто не использует, и позже я вас познакомлю с лучшим способом.`,
                }
            ]
        },

        {
            title: "Каррирование",
            text: [
                {
                    title: "Карри? Карри я люблю",
                    text: `Это потрясающая техника функционального программирования, которая может быть достигнута в JavaScript
                     из-за его способности создавать функции высшего порядка. Каррирование не является частичным применением функции,
                      но помогает в достижении той же цели более функционально. 
                
                      Предсказуемо: каррированная функция сделана так, что она всегда возвращает другую функцию, 
                      принимающую только один аргумент.
                      
                      Потрясающе: каррированная функция всегда запоминает применяемые аргументы из-за замыкания.
                       И все это выглядит круто, когда написано как лямбда-выражение. 😎
                      
                      Чисто: каррированная функция всегда чиста, так как она генерирует одну и ту же функцию для 
                      одних и тех же входных данных.`,
                },
            
                {
                    title: "Реализация каррирования",
                    text: `Каррированная версия нашей функции add():
                    
                    let add = x => y => x+y;
                    let incrementBy2 = add(2);
                    increment(5);
                    increment(6);
                    
                    Красиво... В примере используются стрелочные функции, использовать их советуем и вам.
                     Но олды могут реализовать это на обычных функциях, выглядеть это будет не очень)`,
                }
            ]
        }
    ]
];